package actions

import (
	"github.com/gobuffalo/buffalo"
	"github.com/markbates/pop"
	"github.com/pavanas/brokestest/models"
	"github.com/pkg/errors"
	"github.com/satori/go.uuid"
	"time"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Race)
// DB Table: Plural (races)
// Resource: Plural (Races)
// Path: Plural (/races)
// View Template Folder: Plural (/templates/races/)

// RacesResource is the resource for the Race model
type RacesResource struct {
	buffalo.Resource
}

// List gets all Races. This function is mapped to the path
// GET /races
func (v RacesResource) List(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Get meetings names
	// meetings := &models.Meetings{}

	// err := tx.All(meetings); if err != nil {
	// 	return errors.WithStack(err)
	// }
	
	//races := &models.Races{}
	var races []struct {
		ID        uuid.UUID `json:"id" db:"id"`
		Number    int       `json:"number" db:"number"`
		EndsAt  time.Time `json:"ends_at" db:"ends_at"`
		MeetingID uuid.UUID `json:"meeting_id" db:"meeting_id"`
		Type      string	`json:"type" db:"type"`
	}

	// Retrieve all Races from the DB
	/*if err := tx.BelongsTo(meetings).All(races); err != nil {
		return errors.WithStack(err)
	}*/

	if c.Param("meeting_id") != "" {
		const q_race = `SELECT r.id, r.number, r.ends_at, r.meeting_id, m.type FROM races AS r INNER JOIN meetings AS m ON m.id = r.meeting_id WHERE m.id = ? AND r.ends_at > NOW() ORDER BY r.ends_at`
	
		if err := tx.RawQuery(q_race, c.Param("meeting_id")).All(&races); err != nil {
			return errors.WithStack(err)
		}
	} else {
		const q_race = `SELECT r.id, r.number, r.ends_at, r.meeting_id, m.type FROM races AS r INNER JOIN meetings AS m ON m.id = r.meeting_id AND r.ends_at > NOW() ORDER BY r.ends_at`

		if err := tx.RawQuery(q_race).All(&races); err != nil {
			return errors.WithStack(err)
		}
	}

	//const q_race = `SELECT r.id, r.number, r.ends_at, r.meeting_id, m.type FROM races AS r INNER JOIN meetings AS m ON m.id = r.meeting_id`
	
	// if err := tx.RawQuery(q_race).All(&races); err != nil {
	// 	return errors.WithStack(err)
	// }

	return c.Render(200, r.JSON(races))
}

// Show gets the data for one Race. This function is mapped to
// the path GET /races/{race_id}
func (v RacesResource) Show(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Race
	// race := &models.Race{}
	//meeting := &models.Meeting{}

	// Create a new allocation
	var single_race []struct {
		Number    int       `json:"number" db:"number"`
		EndsAt  time.Time `json:"ends_at" db:"ends_at"`
		Position  int       `json:"position" db:"position"`
		NumberC    int       `json:"number_c" db:"number_c"`
		MType 	   string    `json:"m_type" db:"m_type"`
	}

	//SELECT r.type, r.number, c.position, c.number AS comp_n FROM (SELECT race.id, race.number, meet.type FROM races AS race INNER JOIN meetings AS meet ON meet.id = race.meeting_id) AS r INNER JOIN competitors AS c ON c.race_id = r.id WHERE r.id = '70EF2C1F-9ECE-42B4-BDA0-DAD7852A105E'

	const single_query = `SELECT r.type AS m_type, r.number, r.ends_at, c.position, c.number AS number_c FROM (SELECT race.id, race.number, race.ends_at, meet.type FROM races AS race INNER JOIN meetings AS meet ON meet.id = race.meeting_id) AS r INNER JOIN competitors AS c ON c.race_id = r.id WHERE r.id = ?`

	if err := tx.RawQuery(single_query, c.Param("race_id")).All(&single_race); err != nil {
		return errors.WithStack(err)
	}

	return c.Render(200, r.JSON(single_race))
}

// New default implementation. Returns a 404
func (v RacesResource) New(c buffalo.Context) error {
	return c.Error(404, errors.New("not available"))
}

// Create adds a Race to the DB. This function is mapped to the
// path POST /races
func (v RacesResource) Create(c buffalo.Context) error {
	// Allocate an empty Race
	race := &models.Race{}

	// Bind race to the html form elements
	if err := c.Bind(race); err != nil {
		return errors.WithStack(err)
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(race)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Render errors as JSON
		return c.Render(400, r.JSON(verrs))
	}

	return c.Render(201, r.JSON(race))
}

// Edit default implementation. Returns a 404
func (v RacesResource) Edit(c buffalo.Context) error {
	return c.Error(404, errors.New("not available"))
}

// Update changes a Race in the DB. This function is mapped to
// the path PUT /races/{race_id}
func (v RacesResource) Update(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Race
	race := &models.Race{}

	if err := tx.Find(race, c.Param("race_id")); err != nil {
		return c.Error(404, err)
	}

	// Bind Race to the html form elements
	if err := c.Bind(race); err != nil {
		return errors.WithStack(err)
	}

	verrs, err := tx.ValidateAndUpdate(race)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Render errors as JSON
		return c.Render(400, r.JSON(verrs))
	}

	return c.Render(200, r.JSON(race))
}

// Destroy deletes a Race from the DB. This function is mapped
// to the path DELETE /races/{race_id}
func (v RacesResource) Destroy(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Race
	race := &models.Race{}

	// To find the Race the parameter race_id is used.
	if err := tx.Find(race, c.Param("race_id")); err != nil {
		return c.Error(404, err)
	}

	if err := tx.Destroy(race); err != nil {
		return errors.WithStack(err)
	}

	return c.Render(200, r.JSON(race))
}
